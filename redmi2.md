# سرفصل جامع و کامل آموزش ORM جنگو

## بخش 1: مقدمه
1. **مفهوم ORM و اهداف آن**
   - تعریف ORM و مزایای استفاده از آن در جنگو
   - نحوه ارتباط مدل‌های جنگو با پایگاه داده
2. **ساختار دیتابیس و تطابق آن با مدل‌ها**
   - نحوه تبدیل مدل‌های جنگو به جداول پایگاه داده
   - مفهوم دیتابیس‌ و نحوه اجرای `makemigrations` و `migrate`
3. **طراحی پروژه نمونه برای تمرین عملی**
   - ایجاد مدل‌ها و متدهای ابتدایی

## بخش 2: مدل‌ها و فیلدها
1. **تعریف مدل‌ها و متادیتا (Meta)**
   - بررسی کلاس `Meta` برای تنظیمات مدل‌ها
2. **انواع فیلدها:**
   - متنی (`CharField`, `TextField`, `SlugField`)
   - عددی (`IntegerField`, `DecimalField`, `FloatField`)
   - تاریخ و زمان (`DateField`, `DateTimeField`, `DurationField`)
   - باینری و فایل‌ها (`BinaryField`, `FileField`, `ImageField`)
   - JSON و انواع پیشرفته (`JSONField`, `UUIDField`, `IPAddressField`)
   - **استفاده از `choices`**
3. **ویژگی‌های فیلدها:**
   - `null`, `blank`, `default`, `unique`, `choices`
   - اعتبارسنجی داده‌ها با `validators`
   - ویژگی‌های ظاهری: `help_text`, `verbose_name`, `db_index`
4. **فیلدهای سفارشی (Custom Fields)**
   - ایجاد فیلدهای سفارشی با پیاده‌سازی کلاس‌ها

## بخش 3: تنظیمات پیشرفته مدل‌ها و محدودیت‌ها
1. **unique_together و index_together**
   - تعریف **unique_together** برای تضمین یکتایی ترکیبی فیلدها
   - استفاده از **index_together** برای بهینه‌سازی جستجوها
2. **Constraints**
   - استفاده از `CheckConstraint`, `UniqueConstraint` برای محدودیت‌های سطح دیتابیس
3. **مدل‌های Abstract**
   - استفاده از مدل‌های Abstract برای اشتراک‌گذاری فیلدها
4. **مدل‌های Proxy**
   - تغییر رفتار مدل‌ها بدون تغییر در ساختار دیتابیس
5. **مدل‌های Generic (مدل‌های عمومی)**
   - کار با `GenericForeignKey` و `ContentType` برای پشتیبانی از انواع مختلف داده‌ها

## بخش 4: متدهای مدل و عملیات ذخیره‌سازی
1. **متد `save()`**
   - آرگومان‌های مختلف `save()`:
     - `force_insert` و `force_update` برای کنترل رفتار ذخیره‌سازی
     - اعمال و بررسی اعتبارسنجی‌ها قبل از ذخیره
     - **Override کردن `save()`** برای تغییر رفتار ذخیره‌سازی
2. **عملیات Bulk**
   - استفاده از `bulk_create()` و `bulk_update()` برای ذخیره‌سازی داده‌ها به‌صورت گروهی
   - مزایا و معایب استفاده از Bulk operations

## بخش 5: روابط بین مدل‌ها و مدیریت داده‌های مرتبط
1. **تعریف روابط:**
   - `ForeignKey`, `OneToOneField`, `ManyToManyField`
   - روابط یک به چند، یک به یک، چند به چند
2. **استفاده از `related_name` و `related_query_name`**
3. **مدیریت داده‌های مرتبط:**
   - اضافه کردن، حذف کردن، و فیلتر کردن داده‌های مرتبط
   - عملیات با `through` در رابطه‌های Many-to-Many برای جداول میانه
4. **Cascading Deletes**
   - حذف آبشاری داده‌ها با استفاده از `CASCADE`, `SET_NULL`, `SET_DEFAULT`

## بخش 6: QuerySet‌ها
1. **عملیات پایه روی QuerySet:**
   - `all()`, `filter()`, `exclude()`, `get()`, `count()`
2. **استفاده از `Q` و `F` برای شرط‌گذاری پیچیده**
   - ترکیب شرط‌ها با `Q`
   - مقایسه فیلدها با `F`
3. **متدهای کاربردی دیگر:**
   - `values()`, `values_list()`, `exists()`, `first()`, `last()`
4. **مرتب‌سازی و فیلتر کردن QuerySet‌ها:**
   - `order_by()`, `distinct()`, `reverse()`, `limit()`, `offset()`

## بخش 7: عملیات پیشرفته روی QuerySet‌ها
1. **Annotations و Aggregations**
   - استفاده از `annotate()` برای اضافه کردن محاسبات به داده‌ها
   - توابع Aggregation: `Sum`, `Avg`, `Max`, `Min`, `Count`
2. **استفاده از `Cast` و `Case`**
   - تبدیل نوع داده‌ها با `Cast`
   - استفاده از `Case` و `When` برای شرط‌های پیچیده
3. **Subquery‌ها و Expression‌ها**
   - ایجاد Subquery و استفاده از آن در کوئری‌های پیچیده
   - استفاده از Expression‌ها برای اعمال محاسبات روی داده‌ها

## بخش 8: اجرای Raw SQL
1. اجرای کوئری‌های خام با `raw()`
2. استفاده از `extra()` برای اضافه کردن شرط‌ها و فیلدهای سفارشی
3. استفاده از `connection.queries` برای مشاهده کوئری‌ها در هنگام دیباگ

## بخش 9: تراکنش‌ها و مدیریت آن‌ها
1. **مدیریت تراکنش‌ها با `atomic()`**
   - تراکنش‌های اتمیک با `atomic()`, `commit_on_success()`, `savepoint()`
2. **عملیات روی Savepoints**
   - `savepoint()`, `savepoint_rollback()`
3. **تراکنش‌های چندگانه در کوئری‌ها**

## بخش 10: ایندکس‌ها و بهینه‌سازی
1. **ایندکس‌ها و نحوه استفاده از آن‌ها**
   - استفاده از `db_index`, `unique_together`, `index_together` برای ایندکس‌های پیش‌فرض
   - **تعریف ایندکس‌های سفارشی**
2. **کاهش تعداد کوئری‌ها با `select_related()` و `prefetch_related()`
3. **استفاده از `only()` و `defer()` برای محدود کردن فیلدهای بازگردانی‌شده**

## بخش 11: سیگنال‌ها و ارتباط آن‌ها با ORM
1. **سیگنال‌های پیش‌فرض جنگو:**
   - `pre_save`, `post_save`, `pre_delete`, `post_delete`
2. **تعریف سیگنال‌های سفارشی**
   - ارسال و دریافت سیگنال‌ها در مدل‌ها و استفاده از آنها برای اجرای عملیات پیشرفته

## بخش 12: تست و اشکال‌زدایی ORM
1. **نوشتن تست برای مدل‌ها**
2. **استفاده از دیتابیس‌های تستی**
3. **اشکال‌زدایی کوئری‌ها**
   - استفاده از `django.db.connection.queries`
   - استفاده از `django-debug-toolbar`


# بخش 1: مقدمه به ORM جنگو

## 1.1 مفهوم ORM و اهداف آن
**ORM** یا **Object-Relational Mapping** یک تکنیک برای تبدیل داده‌ها بین زبان‌های برنامه‌نویسی شی‌گرا و پایگاه‌های داده رابطه‌ای است. به عبارت ساده‌تر، ORM به برنامه‌نویس این امکان را می‌دهد که با استفاده از شی‌ها و کلاس‌های زبان برنامه‌نویسی (مثلاً پایتون)، با پایگاه داده رابطه‌ای (مثل MySQL یا PostgreSQL) ارتباط برقرار کند و عملیات‌هایی مانند درج، بروزرسانی، حذف و جستجو را انجام دهد، بدون اینکه نیاز به نوشتن کدهای پیچیده SQL باشد.

### مزایای استفاده از ORM:
- **کاهش پیچیدگی**: برای دسترسی به پایگاه داده از SQL به‌طور مستقیم نیازی نیست.
- **مستقل از پایگاه داده**: کدهای ORM معمولاً قابل استفاده در پایگاه‌های داده مختلف هستند.
- **کاهش خطا**: ORM معمولاً با استفاده از قوانین و قواعد برنامه‌نویسی شی‌گرا، کدها را از لحاظ نگارشی دقیق‌تر می‌کند و خطاهای SQL را کاهش می‌دهد.
- **بالاتر بودن سطح انتزاع**: شما بیشتر با شی‌ها (objects) سر و کار دارید تا جداول و رکوردهای SQL.
- **مقایسه با SQL**: در کدهای ORM نیازی به نوشتن کوئری‌های پیچیده نیست. بسیاری از عملیات‌ها با استفاده از متدها به‌طور خودکار به کوئری‌های SQL ترجمه می‌شوند.

---

## 1.2 ارتباط مدل‌ها در جنگو با پایگاه داده
در جنگو، **مدل‌ها** یا **Models** نمایانگر ساختار جداول در پایگاه داده هستند. به عبارت دیگر، هر مدل جنگو معادل یک جدول در پایگاه داده است.

- **مدل** یک کلاس پایتون است که از `django.db.models.Model` ارث‌بری می‌کند.
- هر متغیر یا ویژگی از کلاس مدل، معادل یک ستون در جدول پایگاه داده می‌شود.
- مدل‌ها معمولاً برای ایجاد جداول و مدیریت داده‌ها در پایگاه داده استفاده می‌شوند.

### ساختار کلی یک مدل در جنگو:

```python
from django.db import models

class MyModel(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)

    def __str__(self):
        return self.name
```
## توضیحات:



هر کلاس داخل models.py یک جدول جدید در دیتابیس می‌سازد.

هر فیلد معادل یک ستون در آن جدول است.

۲. انواع فیلدهای مدل

## در جنگو، فیلدها انواع مختلفی دارند. اینجا به رایج‌ترین‌ها اشاره می‌کنیم:



## متنی:



## CharField: برای متن‌های کوتاه (مثل نام‌ها).

## TextField: برای متن‌های بلند (مثل توضیحات).

## عددی:



## IntegerField: برای اعداد صحیح.

## DecimalField: برای اعداد اعشاری (مثلاً قیمت‌ها).

## تاریخ و زمان:



## DateField: فقط تاریخ.

## DateTimeField: تاریخ و زمان.

## فایل‌ها:



## FileField: آپلود فایل.

## ImageField: آپلود تصویر.

## رابطه‌ای:



## ForeignKey: برای ایجاد رابطه یک به چند.

## ManyToManyField: برای ایجاد رابطه چند به چند.

۳. ایجاد جدول در دیتابیس

## بعد از تعریف مدل، باید جدول آن در دیتابیس ایجاد شود. برای این کار:



## دستورات زیر را اجرا کن:

```bash 
python manage.py makemigrations
python manage.py migrate

```
این دستورات فایل‌های مهاجرت (Migration) می‌سازند و تغییرات را در دیتابیس اعمال می‌کنند.
